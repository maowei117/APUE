# 1.1
在Linux中，唯一标识一个文件的就是它的i节点，所以我们可以通过查看.和..的i节点号来确定它们是不是同一个文件
```
ls -i
```
用上面这个命令可以发现，只有根目录的.和..的i节点号是一样的。

# 1.2
1-6程序的功能是打印出当前进程的pid，第一次打印是851，第二次打印是854，这个题目可能是想问，为什么第二次不是852。进程号的分配是操作系统的行为，和操作系统的实现强相关，有可能在第二次运行程序之前，已经有两个进程先启动了，占据了852和853，也有可能是操作系统分配的策略就不是按照连续分配的策略去做的。

# 1.3
先看一下perror和strerror的定义
```
void perror(const char* msg);
char* strerror(int errornum);
```
其实什么时候用const什么时候不用是比较清晰的一个概念，const修饰的变量是不能修改的，所以用不用const取决于函数的行为，比如这里perror()用了const，是因为msg作为一个输入参数，函数承诺在内部不会对msg的内容进行改变，使用const修饰就明确了这个行为。
如果我们有以下的函数定义：
```
void func(char* msg);
```
这里没有用const，意味着func()内部可能对msg进行了改变也可能没有进行改变，但是实际上在使用时，这样的函数声明则默认在func()中**一定**对msg进行了改变。在设计函数参数时，要根据函数的目的，明确给出参数是不是const。

至于为什么strerror()中没有改变errornum，也没有加const，是因为C语言参数传递默认是pass by value，即传入的是参数的拷贝，所以就算在函数内部改了errornum，也不会影响外面的errornum，所以就没有加const。

# 1.4
带符号的32位整型，其中有一位作为符号位，其最大值为2^31 - 1，日历时间是指的自UTC(1970年1月1日00:00:00)经过的秒数累计值，2^31 - 1秒大概是68年，所以1970 + 68 = 2038年会溢出。
其实Linux中为了解决这样的问题，系统使用的类型大多都是经过封装的，例如时间可能是：
```
typedef long time_t
```
这样当需要改变time_t的类型的时候，只需要改变typedef即可。其实这样的做法也没有办法完全解决兼容性的问题，因为你没办法限制别人怎么使用你的变量，也没办法强迫别人更新系统。如果两台电脑的time_t的定义不同，那么他们之间传输time_t类型的时候就可能会有不兼容。
兼容性确实是个很麻烦的问题，现在解决的办法就是：我提供了标准用法，如果你没按照我的标准用法来用，那么兼容性我就不对你做保证。这样强限制的情况下，如果别人严格按照你设计的接口来用，还是可以保证兼容性的。

# 1.5
带符号的32位整型，最大值为2^31 - 1，一秒100次滴答.

(2^31 - 1) / (100 * 60 * 60 * 24) = 248.5天