# 3.1
本章中描述的函数是Linux中的一些系统调用，包括open(),read(),write()等。Linux在文件处理上，除了有系统调用，还有封装后的C程序库，例如fopen(),fread(),fwrite()等。

他们实现的层次是不一样的，C程序库更加顶层一些，使用了应用级的缓存机制，比如最近被读取的内存可能会被缓存到用户内存上，下次读取的时候就不再进行IO，而是直接从内存读取，这是利用的时间的局部性；还有一种利用空间局部性的，就是在读取的时候，将读取内容附近的内容也取回来（通常会取满一个PAGE_SIZE），这样如果后续读了附近的内容，就可以直接从内存取。

系统调用不同于C库，他在用户区的内存是没有缓存机制的，但是这不意味着系统调用就没有缓存机制。同样系统调用的文件处理函数也是有针对于时间局部性和空间局部性的缓存机制的：

+ 时间局部性：系统调用可能会把读取过的内容保存在高速缓存中，这样下次再读取就不用进行IO。
+ 空间局部性：open的flag可以设置O_DIRECT，如果设置了这个flag那么将会关闭缓存机制, 默认这个flag是不打开的, 所以在默认情况下, 缓存机制是打开的, 当你读取一片磁盘的时候, 操作系统会根据PAGE_SIZE取回附近的内容并缓存在内存中, 如果下次读到附近的内存, 就不用进行IO.

# 3.2
在回答这个问题之前,我们借此机会对Linux的文件系统结构做一个总结. 其实主要有三个结构:
1. 进程表项
2. 文件表项
3. v节点项

我们主要思考一下为什么要这样设计, 其实主要的目的还是出自需求. 我们知道每个文件唯一识别的标志就是它的i节点,这里v节点项中的信息我们可以认为和i节点的信息是差不多的, 所以v节点存在的意义就是保存文件本身的一些信息, 比如说文件的长度, 数据块的位置, 修改的时间等等, 如果没有v节点项, 那么我们就没办法获取到文件本身的信息, 自然无法对文件进行操作.

只有v节点项的话,理论上我们已经可以访问到文件的内容了, 为什么还需要文件表项呢? 文件表项其实是对文件打开方式的一种抽象, 我们知道文件是支持O_RDONLY, O_RDWR等等打开方式的, 在支持多道程序的操作系统中, 不同的进程经常会操作同一个文件, 而不同的进程操作文件的方式可能不一样, 操作文件的位置也可能不一样, 所以就有了文件表项, 对文件的打开方式进行抽象, 对同一个文件的两次打开是两个不同的文件表项, 在这个文件表项中就可以保存这次打开的一些特点(flag), 以及访问的位置(文件的偏移). 如果没有文件表项的话, 那么我们需要自己去记录已经读到了文件的什么位置, 并进行文件操作模式的一些管理.

最后为什么还需要在进程中有fd项呢? fd项其实就是fd到文件表项的map. 我们还是可以假设如果没有fd项, 那么一个进程想要操作文件就需要持有独立的文件表项, 这样有一种需求就无法被满足: 同一个进程中的多个线程想要共享一个文件表项. 所以提供了fd到文件表项的这个map, 就增加了一层使用上的灵活性. 另外, 使用fd来操作文件, 也是一种对底层实现的隐藏.

说回正题, 这里是让我们实现dup2()这个函数, 我们先看一下这个函数的声明:
```
int dup2(int oldfd, int newfd);
```
其中oldfd是我们要copy的fd, newfd是我们指定的fd, 如果成功则返回newfd, 失败返回-1, 并设置errno.

dup2()的功能是拷贝一个fd, 要和oldfd指向同一个文件表项. 在Linux中能够创建一个fd的函数有这样几个: open(), dup系列, fcntl(). 题目中要求不能使用fcntl(), 而open()会指向新的文件表项, 所以我最后决定是用dup()来模仿dup2()的行为(如果用dup3那这个题目就没意义了).
dup()的API是这样的:
```
int dup(oldfd);
```
dup()成功返回的fd是当前系统空闲的最小的fd, 也就是说dup会从最小开始慢慢向上分配. 那么我们只需要一直dup,直到返回的fd == newfd, 然后把之前dup的close()掉就可以了, 代码见[3_2](./3_2.c)

# 3.3
有了我们上面对Linux文件系统的一些概述, 这个问题还是比较简单的.
```
fd1 = open(path, oflags);
```
这一句会创建全局的文件表项, 并在进程表中加入一个fd1.

```
fd2 = dup(fd1);
```
这一句不会改变文件表项, 会在进程表中创建一个fd2, 和fd1指向同一个文件表项.

```
fd3 = open(path, oflags);
```
这一句和第一句一样,会创建全局的文件表项, 并创建fd3, 只不过这里创建的文件表中v节点指针指向的位置和第一句指向的位置一样.

F_SETFD这个flag的作用是影响fd, 所以只会影响进程中的fd->文件表项这个map.

F_SETFL这个flag的作用是改变文件的状态, 而文件的状态是保存在文件表项中的, 所以F_SETFL会改变文件表项.

# 3.4
首先我们需要看一下这个几行代码有什么用：
```
dup2(fd, 0);
dup2(fd, 1);
dup2(fd, 2);
if (fd > 2) {
    close(fd);
}
```
这几行的功能其实就是拷贝一个已经打开的fd，让stdin，stdout，stderr都指向这个文件，其实这就是一个重定向标准输入，标准输出和标准错误的方法。通过这种方式，本来printf()是输出到屏幕上的，我们可以重定向到文件中，实例见[3.4](./3_4.c)

为什么我们最后需要`close(fd)`呢，关闭了之后就只有stdin，stdout，stderr这3个fd指向这个文件了，排除掉原始的fd的干扰。

ps:在做这个实验的时候，我发现了一个很有意思的现象，我是这样打印的:
```
printf("Hello World\n");
printf("What are you doing\n");
perror("error\n");
perror("error2\n");
```
但是得到的结果却是这样的：
```
error
: Undefined error: 0
error2
: Undefined error: 0
Hello World
What are you doing
```
`perror()`的结果反而最先输出在了文件中，但是我先调用的是`printf()`，一开始我还以为是perror和printf之间有什么优先级的关系，但是仔细想了一下，现在他们都指向了同一个文件，应该不存在优先级的问题。后面查了一下才清楚，原来是`perror`中是不带缓冲的，所以会马上写入到文件，而`printf`中是带上了缓冲的，所以直到main函数结束才写入到文件。后面我在printf后面加上了一个`fflush(stdout)`，就得到了下面这样的结果：
```
Hello World
What are you doing
error
: Undefined error: 0
error2
: Undefined error: 0
```

# 3.5
我们先来分析一下shell为什么要用`2>&1`来表示把fd 2重定向到fd = 1的同一文件，为什么要在1前面加上一个`&`符号，其实原因就是因为，如果不加这个符号，单纯一个1表示的是一个文件，文件名是“1”。所以必须要一个特殊的符号，识别这不是一个文件名，而是一个fd对应的文件。

然后看一下这个题目：
```
./a.out > outfile 2 > &1
```
这一句的意思就是a.out的stdout重定向到outfile里面，a.out的stderr重定向到stdout，此时stdout已经指向了文件，结果就是a.out的stdout和stderr都指向了文件outfile.

```
./a.out 2>&1 > outfile
```
这一句就是先把stderr重定向到stdout，一般是终端，然后把stdout重定向到文件。结果就是stdout指向了outfile，而stderr指向了终端。

# 3.6 
代码见[3.6](./3_6.c)，实验之后发现:

1. 可以使用`lseek()`在任意位置读。
2. 但是对于写来说，每次写之前都会把文件指针移到文件的末尾，所以文件只会追加到末尾.
