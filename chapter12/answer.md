# 12.1
我们按照题目的要求实现，代码见[12_1](./12_1.c)。
这个代码很简单，就是一个`pthread_atfork()`的示例程序，为什么我们要使用`pthread_fork()`呢？

当子进程`fork()`父进程的时候，会进程父进程整个地址空间的副本，所以也就继承了互斥量、读写锁、条件变量，但是线程的信息不是在进程控制块中保持的，所以子进程无法继承父进程中的线程，子进程中只会有一个线程，其状态和父进程中调用`fork()`的那个线程一致。

这样就导致了子进程的这一个线程可能没有获得所有的锁（锁的状态不对，有些锁还处于锁住状态），当执行到相应的临界区代码时，子进程的这个线程会由于得不到锁而阻塞，并且完全无法解锁。

为了解决这个问题，有两种解决方案：
1. 对于任何多线程的程序，在`fork()`之后，子进程需要马上`exec()`。
2. 使用`pthread_atfork()`，这个`pthread_atfork()`只能解决互斥量和读写锁的状态问题，不能解决条件变量。

`phtread_at_fork()`的思路是怎样的呢？其实很简单，就是先让父进程中要`fork()`的那个线程获取所有的锁，然后再`fork()`，这样由于进程空间的继承，子进程中的唯一的线程也是获取了所有的锁，然后父进程和子进程再各自释放掉自己的锁就可以了。注意，在`fork()`之后，父进程中的锁和子进程中的锁就没什么关系了，各自管理即可。

回到这个题目本身，我们利用shell对输出重定向，得到的结果如下：
```shell
./12_1 > results
cat results

Parent about to fork.
Thread started...
Preparing locks.
Parent unlocking locks.
Parent returned from fork.
Parent about to fork.
Thread started...
Preparing locks.
Child unlocking locks.
Child returned from fork.
```

其实这个题目和我们上面说的内容没什么关系，就是一个简单的多进程往同一个文件中打印的问题，只要知道这么几点就可以了：
1. 子进程在`fork()`时会继承父进程的打开文件描述符，所以子进程和父进程会打印到同一个文件中。
2. 当打印到终端的时候，终端的缓冲类型是行缓冲，所以调用`printf("xxx\n")`就会马上打印，而打印到文件中默认是全缓冲，所以会在缓冲区满或者程序退出的时候才打印。
3. 由于文件的缓冲区也属于进程的地址空间，所以最后的结果在调用`fork()`之前的`printf`重复了一次。

# 12.2
首先我们要清楚什么是线程安全，什么是异步信号安全。线程安全就是多个线程在同时调用一个函数的时候，最后的行为应该是一致的。异步信号安全就是当线程收到信号，并进行处理的时候，最后的行为是一致的。其实在12.5节中已经讲了如何实现线程安全和异步信号安全：
1. 线程安全：通过对临界区加锁实现
2. 异步信号安全：通过设置锁的属性是`PTHREAD_MUTEX_RECURSIVE`实现。

这里我们直接利用`putenv`来实现`putenv_r`，代码见[12_2](./12_2.c)

# 12.3
图12-13中的`getenv()`为什么不是异步信号安全的呢，因为其中使用了`malloc()`，而`malloc()`底层会有一些操作链表的工作，当被信号打断的时候，对这些底层内存链表的维护就可能会出错。所以题目认为，我们只要在调用`getenv_r()`的时候屏蔽掉所有的信号即可：
```C
sigset_t set;
sigfillset(&set);
sigpromask(SIG_BLOCK, &set, NULL);
getenv_r();
sigprocmask(SIG_UNBLOCK, &set, NULL);
```
如果只是一个单进程的程序，那么确实可以用屏蔽信号的方式来保证异步信号安全，但是如果在多线程的环境下，我们无法保证其他线程也屏蔽了所有的信号，那么当其他线程运行的时候，是可能会打断正在`getenv_r()`的这个线程的，例如当A线程正在`getenv_r()`，执行到`malloc()`时，B线程运行，在其他函数中执行了一个`malloc()`，这时候A虽然屏蔽了信号，也用了锁，但是依然不是可重入的。

# 12.4 
由于我没有FreeBSD的环境，所以这个题目我就不实际运行了。但是我们可以分析一下图12-13的程序是如何来实现线程安全的。

里面用到的api主要有这样几个：
```
pthread_once();  // 用来保证每个线程中初始化的工作只做一次
pthread_key_create();  // 为每个线程创建一个独立的key
pthread_setspecific();  // 把线程的key和特定的数据关联起来
pthread_getspecific();  // 通过key获取与线程关联的数据
```
通过为每一个线程创建一个独立的key，然后关联独立的数据，从而保证了各个线程只访问自己的数据区，达到线程安全的目的。

这个代码的问题在于：当时在FreeBSD环境下malloc不是线程安全的，所以`pthread_key_create()`时可能会coredump，不过现在malloc大多实现为线程安全的，所以这个问题可能已经不存在了。

# 12.5
这个问题其实就是在问我们，什么时候用多线程，什么时候用多进程。

在实际的工程实践中其实用到多线程的场景会比较多，一般来说，如果我们只是想要提高并发能力，都会用多线程，因为多线程的线程切换的开销比较小，线程间的通信也比较简单。

多进程一般用于`exec()`的场景，比如说已经有了一个工具，我们希望在自己的进程中能够执行它，这时候就会`fork()` + `exec()`的方式去执行。

# 12.6
题目让我们实现一个线程安全的`sleep()`，但是又不让我们使用`nanosleep()`，那么首先我们要找到一套定时机制，在图10-29中是用的`alarm()`作为底层的定时机制。我一开始想用`setitimer()`作为定时机制，后来发现答案用了`select()`这种具有超时机制的api作为定时，挺不错，我也采用了这样的做法，代码见[12_6](./12_6.c)

这里因为`select()`是线程安全的，线程之间也没有临界区，所以这个`sleep()`是线程安全的。

# 12.7
显然是不可以的，举一个反例就可以了。比如说一个进程有两个线程A和B，现在A要进行`fork()`了，但是目前持有条件变量锁的线程是线程B。A线程`fork()`后，都没有办法获取条件变量的锁，条件变量的内部状态是不正确的，这时候释放行为是未定义的。

# 12.8
首先我们看一下`timeout()`这个函数的行为是什么：检测超时->创建线程->在线程中执行对应的方法。

题目中说的大大简化我也不清楚作者想要的答案是什么，不过如果让我来实现这样一个`timeout()`，我可以会使用timerfd + epoll，一个任务是一个timerfd，然后放到epoll中触发，不用自己处理超时的逻辑和触发的逻辑，应该算是大大简化吧。