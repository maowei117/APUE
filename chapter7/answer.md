# 7.1
虽然我目前的系统是64位的系统, 但是这个现象在我机器上也复现了. 这是一个比较有意思的问题, 我们可以探索一下原因.
要复现这个问题, 我们需要写以下的代码:
#include <stdio.h>

```
void main() {
    printf("hello world!\n");
}
```
就是把main函数定义为void main(), 然后我们执行
```
./a.out ; echo $?
# 得到的结果是12
```
发现echo得到的结果正好是"hello world\n"这个字符串的长度, 这是为什么呢?


由于ISO C的标准要求main的定义是int main(), 所以我们这种写法, 得到的返回值实际上是未定义的, 在不同编译器实现上可能不同, 在不同的机器上也可能不同.
为了解释这种特殊现象, 需要将这个代码编译成汇编, 然后看看结果, 下面的汇编经过了简化:

```assembly
.LC0:
	.string	"hello world"
	.text
	.globl	main
main:
.LFB0:
	pushq	%rbp
	movq	%rsp, %rbp
	leaq	.LC0(%rip), %rdi
	call	puts@PLT
	popq	%rbp
	ret
```
从这段汇编我们可以看出来, 底层实际上调用了`puts()`去向控制台进行打印, 通过查阅汇编指令的一些规定我们得知, 在GNU x64平台上, 函数的返回值是保存在%rax这个寄存器里面的. 但是在这段汇编里面我们并没有看到对%rax的赋值, 但是由于`puts()`这个函数调用是有返回值的, man page中只是模糊说明`puts()`返回一个非负值时表示成功, 其实经过我们测试发现, 这个非负值就是打印到控制台的字符数. 所以我们就可以解释了, 这里echo的结果正好是字符串的长度是因为:**main函数中没有对寄存器%rax赋值, 但是main函数中调用了puts, puts将%rax赋值为打印成功的字符串的长度**. 

这里补充一句, 之所以有这个现象, 还因为%rax这个寄存器的值在函数调用过程中是不保存的, 也就是说, 被调函数在返回后不保证将%rax恢复到原来的值, 这才导致main中调用`puts()`之后, %rax还是保留了`puts()`的返回值.

然后我们把main函数的返回值定义为int, 得到的汇编结果如下:
```assembly
.LC0:
	.string	"hello world"
	.text
	.globl	main
main:
.LFB0:
	pushq	%rbp
	movq	%rsp, %rbp
	leaq	.LC0(%rip), %rdi
	call	puts@PLT
	movl	$0, %eax
	popq	%rbp
	ret
```
可以看到, 在调用puts后, 增加了一条movl指令, 将%eax赋值为0, 这种隐式返回的情况下, 保证了main的终止状态是0.

# 7.2
之前我们学习过, 终端设备的缓冲模式通常是行缓冲, 所以在遇到一个'\n'字符的时候, 就会flush缓冲区. 而普通文件的缓冲模式通常是全缓冲, 需要等到缓冲区满或者主动调用`fflush()`才会刷新缓冲区. 所以在这里也一样:
+ 如果程序的输出写到终端, 那么由于每个printf中都打印了一个'\n', 所以会立即输出.
+ 如果程序的输出重定向到文件, 那么会等到`atexit()`调用结束后, 执行标准I/O清理程序的时候, printf的内容才会flush, 并一起输出到文件. 

# 7.3
我们再看一遍main函数的声明:
```
int main(int argc, char* argv[]);
```
其实argc和argv是由main的调用方传入的参数, 回想一下shell中的程序执行方式
```shell
cmd [arg1] [arg2] ...

```
同一个程序传入的命令行参数数量可能是不一样的, 所以程序的命令行参数很有可能是保存在heap中的. 那么这个问题就变成:**如何不通过参数传递和全局变量将一个函数中定义的变量传入到另一个函数中**. 目前我能想到的办法, 只有嵌入汇编的方式, 直接操作调用方的栈帧, 如果仅仅使用C语言的话, 目前应该是没办法做到这一点的.

# 7.4 
这个题目想说的意思应该是, 在某些系统中访问地址值为0的地址时, 会有异常信号抛出(比如segment fault). 在C语言中NULL定义为0, 当我们对一个NULL解引用的时候, 说明这个程序实现应该是有问题的, 这些系统应该是想通过强制抛出异常来结束程序, 从而帮助用户更快定位到代码哪里有问题.

# 7.5
这个题目其实就是想让我们用一个typedef来替换`atexit()`参数中的函数指针, 我们首先看一下`atexit()`的定义:
```C
int atexit(void (*func) (void));
```
所以我们可以这样替换:
```C
typedef void Exitfunc(void);
int atexit(Exitfunc* f);
```

# 7.6
calloc在申请内存空间后, 会把空间里面的所有字节都初始化为0, 至于这些字节被解释成什么意义, 那是C语言类型定义的问题了. 对于整数类型而言, 全部字节为0, 其值就是0. 对于指针来说, 目前C语言的定义, NULL也确实是0, 但是毕竟NULL是一个宏, 说NULL == 0是不具备移植性的.

# 7.7
size(1)这个命令, 他的输入是一个ELF文件, 然后能够得到这个文件对应的 text/bss/data段的大小. 一个可执行文件被执行前, 首先需要将text/bss/data段加载到内存, 然后才能执行, 而堆栈是当可执行文件加载到内存后才能知道当前堆栈的大小, 所以size(1)既然没有加载可执行文件, 是没办法知道堆栈的大小的.

# 7.8
这个题目是想说, 为什么`ls -l a.out`得到的文件大小不等于`size a.out`中显示的dec的大小, 原因很简单, 因为一个elf文件中并不仅仅包括text + bss + data段, 他还有可能有其他的段, 除此之外, elf中肯定还有一些空间用于存储文件的元信息, 例如elf的header, 不然的话例如`file(1)`和`size(1)`这样的工具就没办法判断一个文件是不是elf文件了.

# 7.9
当我们使用静态链接得到一个可执行文件的时候, 会把用到的所有库函数和底层的实现都拷贝一个副本到可执行文件里面, 所以得到的可执行文件会比较大. 当我们使用动态库链接的方式得到这个可执行文件的时候, 只是在符号表中保存了库函数的符号, 然后等到调用的时候才去查找, 加载库函数的实现, 所以得到的可执行文件会比较小.
我们通过`nm(1)`命令, 对比静态链接和动态链接生成的可执行文件就会发现, 静态链接生成的可执行文件中包含很多库函数的符号的拷贝.

# 7.10
这段代码其实是想表达这样一个问题: 由于函数的栈帧在函数返回后会pop, 所以我们不能在函数已经返回之后继续使用他原来栈帧中的信息, 例如该函数中的局部变量, 这是我们已经知道的. 那么如果我在函数内部有一个作用域, 我能不能在退出这个作用域后访问这个作用域中的局部变量呢?

我认为这种用法同样是undefined的, 和编译器的实现有关, 如果编译器实现的时候始终为这个内部的作用域保留空间, 那么可能结果是没问题的. 但是这种用法本身是不符合标准的, 结果应该是undefined, 我们可以说这种用法是不正确的.