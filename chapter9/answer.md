# 9.1
通过这个题目我们可以把login和logout的整个流程弄清楚一下:
1. 首先主机一开始的状态是启动了init进程, 然后init进程中启动了很多子进程, 其中包括tty管理进程, 用于管理网络登陆的进程(inetd)等
2. tty管理进程连接到终端后, exec login进程
3. login进程接受来自终端的输入(账号密码等信息), 然后和/etc/shadow中的密码(加密后的)进行验证, 如果通过了, 那么就会视为一次成功的登陆, 这时候login会把登陆信息写入/var/run/utmp中, 并且将登陆的历史记录写到/var/log/wtmp中. 
4. 登陆成功后, login进程会exec shell进程, 并在shell进程中处理用户输入输出.
5. logout时, shell进程会退出, shell的父进程, 也就是init进行, 中会进行wait(), 记录logout信息到/var/log/wtmp中, 并释放对应的资源.

为什么logout是由init进程写的, 就是因为只有init进程作为shell的父进程知道logout的信息.
对于网络登陆而言, 其实就是第二步, 伪终端不是init的子进程, 而是网络登陆管理进程(inetd/telnetd等)的子进程.

# 9.2
利用这个题目, 我们把本章里面的一些核心概念做一下回顾.

1. 终端. 终端这个概念其实是相对于主机而言的, 终端其实就是为了人机交互才存在的. 主机执行很多程序其实是不需要人为的参与的, 也就是说, 只需要CPU, 内存, 磁盘这些电路组起来, 就能跑程序. 为什么需要终端呢? 就是因为作为程序员, 我其实只能通过键盘/鼠标/屏幕来和主机传递信息. 这个人机交互的接口其实就是终端. 终端在Linux中是被抽象成了一个文件的形式. 所以我们可以通过`open()`, `read()`, `write()`去从终端获取信息或者向终端传递信息. 而具体的实现其实是通过终端的驱动程序来做的. 主机启动时运行的第一个进程是init进程, 在这个进程中, 就会去open()终端文件, open之后, stdin/stdout/stderr就指向了终端文件, 然后我们就可以利用实际的终端硬件(键盘/显示器)来和主机交互了. 比如说当我们在键盘上敲下一个'a', 这时候键盘会产生一个中断信号发给主机, 主机发现这个中断信号是键盘传过来的, 于是就会去read()键盘对应的文件, 从而就会调用键盘驱动程序, 键盘驱动程序的实现中可能就包含了一个回显, 即向stdout `write()` 'a'这个字符, 于是显示器的驱动程序就会把字符 'a' 显示到屏幕上, 这样我们就看到了我们输入的 'a'. 当然, 有时候我们是通过网络登陆的, 这时候并没有一个实际的键盘/显示器硬件和主机相连, 这时候就有一个伪终端的概念, 伪终端模拟终端驱动程序的行为. 当我们通过ssh登陆的时候, 一个新的连接创建时就会创建对应的伪终端, 然后请求包到达时, 会发给伪终端, 伪终端也会执行和终端类似的操作.

2. shell. 记得刚开始接触Linux的时候, 我一直分不清终端和shell之间的区别, 其实现在看来还是很容易区分的. 终端只是为我们提供了一个人机交互的途径, 但是终端并不会去解析我们发给它的内容. 而shell其实本质上就是一个解析用户命令的软件. init进程在打开终端的文件并登陆成功后, 就会以fork()的方式启动shell进程, 这样shell进程就可以获取终端的输入输出了. shell这个软件既可以通过 `fork()` + `exec()` + `wait()`的方式启动子进程并运行别的程序, 也可以解析shell脚本, 执行一些对应的命令. 

3. 进程组. 有些时候, 我们需要对一组进程进行统一管理. 比如说有时候我们需要向一组进程同时发送信号(使用`kill()`, 且pid < 0的时候就是发送给一个进程组). 这时候我们就有了进程组的概念. 当我们通过shell运行一个进程的时候, 会同时创建一个进程组, gid就和这个进程的pid相同, 当我们fork一个子进程的时候, 会继承父进程的进程组(测试可以看[这里](./gid_test.c)).

4. 会话. 进程组的这个概念有时候还不够用, 在涉及到作业控制的操作系统中. 有时候经常需要把进程分成好几个进程组(这样不同的进程组能够分别接收信号).但是这些不同的进程组又存在一定联系, 比如他们都是同一个shell的子进程, 这时候就有了会话这个概念. 我理解会话就是为了作业控制产生的一个概念, 在一个会话中, 进程组分为了会话首进程, 前台进程组, 后台进程组, 这样驱动程序才能根据进程组的类型和进程组进行交互. 比如说只有前台进程组才能接收终端的输入, 后台进程组接受终端的输入的话, 终端的驱动程序会发出SIGTTIN信号等等.

5. 作业控制. 作业控制其实是操作系统实现的一种功能, 通过一个会话的方式, 能够把多个进程组统筹起来. 作业控制的实现需要操作系统, shell, 终端驱动等多方面的配合. 最终实现的效果就是: 一个shell下的所有进程组成了一个会话, 下面分为前台进程组和后台进程组(最多只能有一个前台进程组, 后台进程组可以有多个). 这种作业控制方式允许我们能够同时运行多个进程, 而且在与终端交互的情况下, 由于只有前台进程组能接受终端的输入, 所以输入也不会乱掉. 

现在我们回到这个题目本身, 代码见[9_2](./9_2.c)