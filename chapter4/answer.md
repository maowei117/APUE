# 前言
本章的写作逻辑其实很简单，就是从`stat()`这个函数出发，引出UNIX系统中文件的各种属性，进而引出针对每个属性的操作。学习本章主要就是要搞清楚UNIX文件系统的组成方式。

# 4.1
图4.3的程序其实很简单，就是把命令行参数都认为是一个文件的path，然后直观地打印出对应的文件是哪种类型的文件，我们可以做一个对比的程序，把stat和lstat的结果都打印出来，代码见：[4_1](./4_1.c)
尝试之后可以发现，其实`stat()`和`lstat()`之间的区别主要在于`stat()`会follow symbolic，也就是说，当打开的文件是一个软链接的时候，stat得到的信息实际上是软链接指向的文件，而`lstat()`则不会这样，当打开的文件是一个软链接的时候，`lstat()`得到的是这个软链接文件本身的信息，所以得到的文件类型也是symbolic link，知道了这个行为，我们猜测，这个`lstat()`中的l，就是link的意思，用于获取link的stat。

到这里这道题就算是结束了，但是我们还可以看一下`sturct stat`中`st_mode`是怎么组织的。这个`st_mode`一个字段可以表示7种文件类型，其实就是用了位运算，在我所在的系统中，位运算是这样做的：
```
#define S_IFMT          0170000         /* [XSI] type of file mask */
#define S_IFIFO         0010000         /* [XSI] named pipe (fifo) */
#define S_IFCHR         0020000         /* [XSI] character special */
#define S_IFDIR         0040000         /* [XSI] directory */
#define S_IFBLK         0060000         /* [XSI] block special */
#define S_IFREG         0100000         /* [XSI] regular */
#define S_IFLNK         0120000         /* [XSI] symbolic link */
#define S_IFSOCK        0140000         /* [XSI] socket */

#define S_ISBLK(m)      (((m) & S_IFMT) == S_IFBLK)     /* block special */
#define S_ISCHR(m)      (((m) & S_IFMT) == S_IFCHR)     /* char special */
#define S_ISDIR(m)      (((m) & S_IFMT) == S_IFDIR)     /* directory */
#define S_ISFIFO(m)     (((m) & S_IFMT) == S_IFIFO)     /* fifo or socket */
#define S_ISREG(m)      (((m) & S_IFMT) == S_IFREG)     /* regular file */
#define S_ISLNK(m)      (((m) & S_IFMT) == S_IFLNK)     /* symbolic link */
#define S_ISSOCK(m)     (((m) & S_IFMT) == S_IFSOCK)    /* socket */
```
是8进制的位运算，实际上只用了4位就表示了这些文件类型。其实UNIX系统中很多用到了这种技巧，当想要节约空间的时候，一个int字段，可能会表示多种类型的信息，比如说其中的几个bit想要表示mode，另外一些bit想要表示link size，就可以不暴露底层的实现，而是通过定义一些宏的方式来操作这个字段。对于现在的硬件来说，这点空间可能已经无足轻重了，但是在很多嵌入式环境里面，这种技巧用得很多。

回到我们这里的st_mode来，这里我们可以看出用于表示文件类型并没有用完st_mode的所有bit，其实其中有一个S_ISUID位和S_ISGID位，他们的作用就是表明这个文件在执行的时候，不管执行的实际用户是谁，都具有和文件的所有者一样的权限。`passwd`这个程序就是利用这个原理，不论是谁都可以更改passwd文件（尽管文件的权限是属于root的）。这两个bit其实很有用，这相当于一种受限的权限放宽，只有在执行passwd程序的时候才会具有root的权限，那么就意味着其他用户的行为还是受到了passwd这个程序的行为限制，只要passwd程序写得没有漏洞，那么就还是安全的。

除此之外，st_mode中的一些bit(9个)用来表示了文件的访问权限：S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH.

这就是st_mode的三个方面的功能：
1. 用于表示文件的类型
2. 用户表示文件在执行时是否具备和文件所有者/所有组一样的权限
3. 用于表示文件的访问权限信息

# 4.2
在回答这个问题之前我想要先说一下对于文件和目录而言，rwx权限的意义。
对于文件而言：
+ r权限：就是可以读取文件，能够把文件的内容读取到内存中。
+ w权限：就是可以写文件，能够把内存里面的内容写入到文件中。
+ x权限：可以执行文件，能够作为二进制程序或者脚本执行。

对于文件而言，rwx权限还是比较直观的，但是对于目录而言，目录我们知道是一种特殊的文件，每个目录也是有自己的inode的，只不过目录的数据部分保存的内容是该目录下的文件/目录的inode号->名称的一个列表。目录也有对应rwx权限：
+ r权限：可以读取目录文件，这样就可以列出该目录下包含哪些文件和目录。
+ w权限：可以写入目录文件，也就是说可以向这个目录中添加一些文件和目录。
+ x权限：搜索权限，这个权限我打算好好说一下。上面说了目录是一个inode号->文件名的列表，如果我们只有r权限的话，那么我们只能读取到目录文件本身，也就是可以得到这些文件名和inode号，但是我们是不能做进一步的操作的，只有我们有目录的x权限，我才能对这个目录下的文件进行操作。比如说我现在有目录/a/， 然后在这个目录下有/a/a.txt，如果我想要打开这个a.txt的话，那么我一定要对目录/a/有x权限。简单来说就是，如果目录没有x权限，那么这个目录下的所有文件你都不能操作，只能单纯当成字符串来处理。

弄清楚这一点之后，还需要弄清楚一点的就是操作系统是如何来判断一个用户对一个文件到底有没有访问权限的，其实顺序是这样的：
1. root用户对所有文件都有访问权限，也就是说root用户是无视所有的访问规则的，都可以访问。
2. 首先看文件所有者的权限，如果进程的有效用户id是文件所有者id，那么就按照文件所有者的权限来执行。
3. 只有在进程的有效用户id不是文件所有者的情况下，才会去看一下组id，如果有效用户在文件对应的组中，就会按照组权限去执行
4. 如果既不是文件所有者，又不是组内的用户，就会按照other的权限来执行。
   
这里有一个很有意思的地方，就是一旦找到了对应的权限，就不再继续看其他权限了，比如说，用户有效id是文件的所有者，但是文件的所有者对这个文件的权限是0，也就是没有任何权限。但是同时这个实际用户还处于这个组中，而这个组队这个文件的权限是7。这种情况下，进程对文件的权限还是0，也就是说按照上面这4步，第一个匹配到的规则就是最后用户对这个文件的权限。

回到这个题目，说的是把umask设置为777会怎么样，umask设置的是屏蔽的权限，所以就是屏蔽了所有权限，结果就是默认情况下创建的文件和目录的权限都是000.

# 4.3
这个问题也很好验证，我们可以通过`chmod u-r`来关闭用户读权限. 
```
echo "hello world" > a.txt

cat a.txt

chmod u-r a.txt

cat a.txt
```
执行上面这几句，就会发现当没有了read权限之后，就没办法cat a.txt的内容了，会显示Permission denied.

# 4.4 
这个问题比较简单，在umask之前创建的文件，当然不受后续的umask的影响，会保持创建时的权限不变。

# 4.5 
`st_size`这个字段保存的是文件的大小，在目录这种类型的文件中，保存的是文件名到inode号的映射，而目录文件中始终包含了`.`和`..`这两项，所以目录的大小始终不为0；对于符号链接文件来说，保存的就是链接的文件名，是一个string，同样也不会为空，不然就没办法链接到别的文件了，所以符号链接文件的大小也始终不为0.

# 4.6
要解决这个问题，我们要知道什么叫做空洞(hole)：
首先我们知道磁盘是一个顺序存储的结构，磁盘空间是一块一块进行分配的，而不是一个byte一个byte进行分配的。比如我们写入一个`abc\0`到文件a.txt里面，每个字符一个byte，一共4byte，但是操作系统在分配磁盘的时候必须要把整个块都分配给这个文件。这就导致了，我们通过`ls -l`去看，发现a.txt文件大小是4byte，但是通过`du -h`去看，却发现这个文件实际占用了4K的空间（具体大小和操作系统有关）。空洞是如何形成的呢，当我们写入文件不是连续的，比如说我们通过`lseek()`去改变文件的偏移，然后写入，这时候文件的大小虽然改变了，但是由于通过`lseek()`跳过的部分我们并没有写入，所以操作系统可能根本没有为这些地址分配空间，很多操作系统的实现都是这样的，目的主要是出于节省数据块。因为我只需要在inode中去记录这个块并没有写入文件就可以了，不需要分配数据块。

为了完成这个练习，我们需要先生成一个有空洞的文件，代码也很简单[make_hole_file.cpp](./make_hole_file.cpp)
生成了这个空洞文件`hole_file.dat`之后,我们分别用cat和cp的方式来复制一下这个文件,确实能够看出,cp会跳过空洞部分的数据块,导致`hole_file.copy`使用的磁盘的大小和`hole_file.dat`是一样的,而cat则会为空洞中的0分配磁盘块,导致`hole_file.cat`使用的磁盘空间大于`hole_file.dat`:

```shell
ll hole_file.*
-rw-rw-r-- 1 tommao tommao 12365 10月 21 23:03 hole_file.cat
-rw-r--r-- 1 tommao tommao 12365 10月 21 23:03 hole_file.copy
-rw-r--r-- 1 tommao tommao 12365 10月 21 23:02 hole_file.dat

du -h hole_file.*
16K	hole_file.cat
8.0K	hole_file.copy
8.0K	hole_file.dat
```

回到我们这个问题,我们怎样才能写一个和cp(1)一样效果的程序呢? 首先我们要能够知道哪里存在空洞, 当遇到了空洞后, 我们直接跳转到下一个不是空洞的位置, 然后写入即可. 这里要注意的点有两个:
1. 识别空洞, 在Linux系统中, 空洞位置的byte是写0的, 但是写0的不一定都是空洞, 也有可能存在正常的文件内容是0的. 在Linux3.1版本后, 可以通过`lseek()`中的flag:`SEEK_DATA`和`SEEK_HOLE`来找到数据的位置和空洞的位置. 但是经我测试, 我的系统上并不支持. 为了能够尽量提高程序的移植性, 我决定还是用内容为0来识别空洞, 这样有可能把正常的数据识别为空洞, 从而导致cp后的文件使用的磁盘块数比原来的小. 
2. 由于文件的数据是一块块存储的, 所以我们在cp的时候, 应该以块为单位进行cp. 只要一个块中有一个位置不是空洞, 那么这个块就应该被分配.

最后编写的代码见[4_6](./4_6.c), 为了让逻辑显得清晰, 代码中省略了部分异常判断.

# 4.7
这个题目其实是想要帮助我们理解`umask`的功能. `umask()`这个系统调用控制的是**进程**在创建文件时的屏蔽字, 也就是说, 不同的进程是可能会有不同的umask值的, 就算在同一个进程中, 也可能改变umask的值. 我们通过`open()`创建文件的时候, 除了根据flag来对文件的st_mode中权限进行设置, 还需要结合当前这个进程的umask值, 将对应的位屏蔽掉, 最终得到产生文件的权限.
理解清楚了umask的功能之后, 来看一看题目中的例子:
```
-rw-r--r-- core
-rw-rw-r-- core.copy

```
其中core是原先存在的文件, 而core.copy是`cat core > core.copy`生成的. 其中core文件的umask是生成core文件的进程决定的, core.copy文件的umask是由cat这个进程决定的. 如果这两个umask值是一样的话, 那么两个文件权限不同的原因就只能是因为进程在生成文件的时候设置的权限位不同了. 例如两个进程的umask都是0002, 但是core文件生成的时候指定的flag是0644, 而core.copy文件在生成的时候flag为0664. 总之我们只要知道, 进程生成的文件的实际权限位由两个部分决定:
1. 创建文件时给定的权限位.
2. 创建文件时进程的umask值.

# 4.8
图4.16的程序目的是为了说明, 当文件已经被打开后, 调用`unlink()`不会马上将文件的内容删除, 仍然可以通过fd访问该文件. 系统也不会把对应的数据块标记为可用. 只有当进程退出后, fd结构被销毁, 这时候才会回收被`unlink()`删除的数据块. 

为了比较df和du的差别, 我执行了图4.16的程序, 得到的结果如下:
```shell
# before unlink
1528748	. 
/dev/sdb6      99379328 2488044 91800008    3% /home

# after unlink, before process exit
936	.
/dev/sdb6      99379328 2488044 91800008    3% /home

# after process exit
936	.
/dev/sdb6      99379328  960188 93327864    2% /home
```
其实为什么不使用du来统计磁盘, 而使用df是因为他们两个的原理是不同的.
du是找到对应的文件(如果是目录的话, 会默认以递归的方式访问目录下的所有文件), 然后得到文件占用磁盘的大小. 而df是返回操作系统中所有文件系统的可用块信息. 当我们执行`unlink()`之后, 即使文件已经被打开了, 还是会马上删除目录中这个文件的记录, 因此du统计出来的磁盘占用中根本没有这个文件的信息了.
所以我们使用df, 通过df显示的该文件系统的可用块数, 我们就能知道`unlink()`删除的文件, 他的数据块是不是也被标记为可用了.

# 4.9
我们首先把文件中的三个时间回顾一下:
1. atime = access time, 记录的是文件的内容被访问的时间, 也就是文件的data块被访问的时间. 这就是为什么open()在O_TRUNC这个flag下居然没有改变文件的access time, 因为TRUNC这个操作只需要将i节点里面的文件大小和data块索引的信息抹去就可以了, 完全不需要访问到数据块.
2. mtime = modify time, 记录的是文件的内容被修改的时间, 只要文件的内容发生了改变, 这个值就会改变. 但是如果文件的内容没有改变, 只是inode中的一些字段发生了改变, 这个mtime是不变的.
3. ctime = change time, 记录的是文件的inode被修改的时间, 一般来说, 只要mtime发生了改变, 那么这个ctime是一定被改变的. 因为mtime是inode中的一个字段.

然后我们来看一下`unlink()`这个系统调用, 他的功能是将文件的st_nlink值减少,如果这个值变成0, 那么就把对应的inode, data块都回收. 所以很显然`unlink()`会修改inode的字段的, 所以ctime会随之改变.

# 4.10 
myftw的实现方式很简单, 就是用深度优先遍历的方式, 从一个起始点开始遍历了目录结构. 目录是一种特殊的文件, 所以`opendir()`产生的描述符也是受到操作系统的限制的. 用递归的方式实现的深度优先, 只有在最后遇到叶子节点的时候才会返回, 所以系统的可打开文件数就是限制了递归的深度, 也就是限制了myftw遍历文件树的深度.

# 4.11
在书中的4-22节实现的ftw的, 原理很简单, 就是通过递归的方式拼出每个文件的**全路径名**, 然后通过`lstat()`获取文件的类型, 然后用一个全局的计数器来对各种文件的类型进行计数. 而本题中想让我们不要去拼接这个全路径名, 而是使用`chdir()`进入到目录中, 使用文件的**相对路径名**来进行统计. 
我们将两个版本的ftw都实现, 然后比较一下耗时, 代码见[4.11](./4_11.c), 其中`ftw_absolute()`使用全路径名, `ftw_relative()`使用相对路径.
为了简便, 我们使用一个固定长度的buffer来存储路径名.
最后得到的结果如下:
```shell
ftw_absolute timecost_us:4371
ftw_relative timecost_us:1730

```
我测试了不同的起点, 发现使用`chdir()`的方式耗时总是比`strcpy()`拼接的方式要短. 其实原因我们从代码的实现就能看出来:
当我们使用ftw_absolute的时候, 底层的操作为一次`strlen()` + 一次`strcpy()`的函数库调用, 其中`strcpy()`进行了内存的拷贝, 是比较耗时的.
而我们使用ftw_relative的时候, 底层的操作是两次系统调用`chdir()`, 这个函数应该只是修改了进程表中的一个指针, 所以没那么耗时. 如果想要详细的对比, 可以使用工具valgrind记录两个函数的热点信息, 这里我们就不做这一步了.

# 4.12
阅读`man 2 chroot`我们可以发现, chroot的机制仅仅是改变了进程对于文件路径解析的方式. 

> This call changes an ingredient in the pathname resolution process and does nothing else.

我们在代码[4_12](./4_12.c)中尝试了一下这个api, 当调用了`chdir(path)`之后, 当前的进程将以path作为根目录. 看上去这可以为子进程创造一片独立的文件系统目录结构, 比如说我们`chdir("./test")`, 那么当前的进程及其子进程都会以`./test`作为根目录`/`. 但是man中特别提到了, 使用这种方式创建的sandbox是不靠谱的, 有漏洞, 不建议我们去使用这个api用作这个目的.

# 4.13
这个题目很简单, 主要讲的是`utimes()`的使用.
```C
int utimes(const char* filename, const struct timeval times[2]);
```
这里times[0]保存的是access time, times[1]保存的是modify time, 由于我们必须同时传入这两个值, 所以我们可以首先通过`stat()`获取对应文件的这两个时间, 如果只想改变access_time, 那么就把times[0]设置为新的值, 让times[1]保持和`stat()`中st_mtim保持一致即可, 反之类似.

# 4.14
这个问题听起来就像是在考察atime, mtime和ctime; 收到新的邮件应该是一个文件被创建的时间, 所以用mtime来表示比较合适, 是否阅读是一个文件被访问的时间, 用atime比较合适.

# 4.15
这个问题估计是中文翻译有点问题, 导致这个题目很难看懂, 其实作者是想问这样一个问题: 我们知道打包工具可以将多个文件打成一个包, 然后在解包的时候, 又可以其他位置把这些文件解出来. 作者希望我们首先使用一下`cpio`和`tar`这两个工具, 然后观察一下打包和解包过程中对处理文件的atime, mtime, ctime有什么影响, 最后分析一下这两个工具是怎么实现对这些时间的修改的.

为什么会有这个问题呢, 因为当我们对文件进行打包的操作时, 打包工具会读取原文件, 所以应该是会修改atime的, 而当我们对文件进行解包的时候, 实际上是创建了新的文件, 这时候按道理说文件的mtime应该是解包的时间, 但是可能有些打包工具会保存原来文件的mtime, 然后在解包后把mtime修改为和原始文件的mtime一致. 这个题目就是让我们调研一下这两个工具在打包和解包的过程中实际的行为是怎样的.

知道了这些之后我们来做这个实验, 首先我们创建一个文件test.txt, 然后用`stat`命令看一下它的三个时间, 然后我们分别用cpio和tar进行打包, 然后把包解压到另外一个目录, 对比一下解压出来的文件的三个时间有什么变化.

```shell
# 创建文件text.txt
echo "test" > test.txt

# 查看test.txt的三个时间
stat test.txt
# 结果如下
atime：2020-11-19 00:31:26.835363588 +0800
mtime：2020-11-19 00:31:26.835363588 +0800
ctime：2020-11-19 00:31:26.835363588 +0800

# 使用cpio打包, cpio需要用一个文件来写明要打包的文件列表, 这里cpiolist就是这个列表, 里面就一行"test.txt"
cpio -o < cpiolist > test.io
# 查看test.txt时间的变化
stat test.txt
# 结果如下, 我们发现cpio确实改变了文件的atime, 因为打包时需要读取文件.
atime：2020-11-19 00:32:56.678888294 +0800
mtime：2020-11-19 00:31:26.835363588 +0800
ctime：2020-11-19 00:31:26.835363588 +0800

# 使用cpio解压, 解压到一个不同的目录, 以免覆盖
mkdir cpio
cpio -D cpio -i < test.io
stat cpio/test.txt
# 结果如下, 我们发现atime, mtime和ctime全部都变成了解包时的时间, 也就是说cpio没有保存原始文件的时间, 解包时由于新创建了文件, 所以时间都是
# 创建文件的时间.
atime：2020-11-19 00:44:02.759245585 +0800
mtime：2020-11-19 00:44:02.759245585 +0800
ctime：2020-11-19 00:44:02.759245585 +0800


# 然后我们测试一下tar的行为, 首先获取原始文件的三个时间
stat test.txt
# 结果如下
atime：2020-11-19 00:32:56.678888294 +0800
mtime：2020-11-19 00:31:26.835363588 +0800
ctime：2020-11-19 00:31:26.835363588 +0800

# 然后使用tar进行打包
tar czf test.tgz test.txt
# 查看一下test.txt的时间变化
stat test.txt
# 结果如下
atime：2020-11-19 00:32:56.678888294 +0800
mtime：2020-11-19 00:31:26.835363588 +0800
ctime：2020-11-19 00:31:26.835363588 +0800

# 使用tar解压
mkdir tar
tar xzf test.tgz -C tar
stat tar/test.txt
# 结果如下, 我们发现atime和ctime是解包时的时间, 但是mtime保留了原始文件的mtime, 精度为秒, 纳秒部分被全部抹0了.
atime：2020-11-19 00:51:48.996369949 +0800
mtime：2020-11-19 00:31:26.000000000 +0800
ctime：2020-11-19 00:51:48.996369949 +0800
```

从上面的实验我们就能够得到结论:
cpio默认的情况下不会保存原始文件的atime, mtime和ctime, 解包就是创建新的文件, 新文件的这三个时间都是按解包的时间来确定的.
tar默认的情况不会保存原始文件的atime和ctime, 但是会保存mtime的tv_sec, 也就是说tar在打包的时候会保存文件的mtime的tv_sec, 并且在解包后将对应文件的mtime->tv_sec修改成和原文件一致, mtime->tv_nsec = 0.

cpio和tar工具都有一些选项是可以控制这些时间的行为的, 比如说cpio的-a, -m以及tar的-m等, 这里就不再赘述了.

# 4.16
验证的代码见[4_16](./4_16.c)通过这个问题, 我们思考一下这种深的目录结构意味着什么. 我们知道目录是一种特殊的文件, 其中的每一项都是一个inode号到文件名的映射. 当我们创建一个目录的时候, 实际上做了这样几件事情:
1, 创建了一个inode, 类型是目录类型, 目录中有 . 和 .. 这两项, 其中.对应的inode号是目录自己的inode, ..对应的inode号是其父目录的inode号.
2, 在当前目录的父目录中加入一项, 其中文件名是目录的名字(我们这里叫做"test_dir_name"), inode号是刚刚创建的目录的inode号.

看清楚了这2步, 我们发现, 目录结构的深度其实只受到文件系统能够创建的最大文件数限制和文件系统的容量限制.

然后我们来回答一下本题中的几个问题:
1, 可以调用getcwd来获取目录的路径, 只要我们传入的buffer足够大即可. 在4_16中, 当我们getcwd失败的时候, 我们就把buffer长度变成当前的2倍, 终于当buffer长度足够时, 便得到了cwd. 
2, 标准的UNIX系统工具比较多, 我们这里就只测试了一下ls, 结果在我的ubuntu环境下显示"文件名过长", 说明当路径名太长的时候, 一些常用的工具就用不了了, 可能是因为这些工具里面使用了一个定长的buffer, 当路径名太长的时候就直接返回了. 
3, 在我的机器上, 不能用tar和cpio对这个目录进行归档.

# 4.17
这个问题也很简单, `unlink()`的原理是先将文件从父目录中移除, 然后再把文件对应的inode, 数据块标记为空闲. 所以我们删除一个文件需要具有其父目录的w权限, 但是我们发现/dev/fd/1, 的父目录权限为dr-x------, 即使是owner都没有w权限, 所以用户是不能直接往这个目录添加文件的.

实际上/dev/fd是一个软链, 链接到/proc/self/fd. /proc这个挂载点是一个特殊的挂载点, 其中的文件不是真正的磁盘上的文件, 而是操作系统将内存中的一些信息以文件的形式抽象出来的, 详情可以查看`man proc`

